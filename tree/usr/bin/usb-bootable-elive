#!/bin/bash
source /usr/lib/elive-tools/functions
el_make_environment
. gettext.sh
TEXTDOMAIN="usb_bootable_elive"
export TEXTDOMAIN

guitool="/usr/bin/zenity --window-icon=/usr/share/icons/gnome/256x256/apps/logo-elive.png"
url_elive="www.elivecd.org"
cache_dir="$HOME/.cache/$(basename $0)"
TMP_PROGRESS_WORKING_f="${cache_dir}/progress-file-working"
TMP_ERROR_LOGS_f="${cache_dir}/logs-error.txt"
wgetopts="--tries=40 --progress=dot:binary -c"
#set -E

# Lock system (good one) {{{
lockfile="/tmp/.$(basename $0)-${USER}.lock"

exit_ok(){
    guitool working_stop
    rm -f "$lockfile"
    kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null || true
    rm -f "$TMP_ERROR_LOGS_f" "$TMP_PROGRESS_WORKING_f"
}
exit_error(){
    guitool working_stop
    rm -f "$lockfile"
    kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null || true
    if [[ -s "$TMP_ERROR_LOGS_f" ]] ; then
        guitool error "$( eval_gettext "Aborted tool for recording Elive to an USB." )\n\n$(tail -2 "$TMP_ERROR_LOGS_f")"
    else
        guitool error "$( eval_gettext "Aborted tool for recording Elive to an USB." )"
    fi
    guitool info "$( eval_gettext "If there's an issue with the tool we suggest to report it to Elive. You can also try to delete the next directory:" ) $cache_dir"

    rm -f "$TMP_ERROR_LOGS_f" "$TMP_PROGRESS_WORKING_f"
}

if [[ -r "$lockfile" ]] ; then
    PROCCESS="$(cat $lockfile)"
else
    PROCCESS=" "
fi
if (ps up $PROCCESS) 1>/dev/null 2>&1 ; then
    el_error "$(basename $0) already running"
    exit
else
    echo $$ > "$lockfile"
fi

# traps needs to be after the lock verification, in order to not remove it when we are already running
trap "exit_ok" EXIT
trap "exit_error" 1 3 5 6 14 15 ERR TERM

# SET the lock file
echo "$$" > "$lockfile"

# }}}
# this function generates the menu with the USB device to select
generate_menu_selector(){
    # build menu variable from partitions list {{{
    #  device :: type :: filesystem :: label :: human_label :: size :: human_size :: uuid
    unset menu id_vendor
    while read -ru 3 entry
    do
        part="$( echo "$entry" | awk -v FS="::" '{print $1}' )"
        [[ ! -b "$part" ]] && continue
        # ignore partitions (end in numbers)
        if echo "$part" | grep -qs "[[:digit:]]$" ; then
            continue
        fi

        if /sbin/udevadm info --query=property --name="$part" | grep -qs "ID_USB_DRIVER=usb-storage" ; then
            # create an array for use in the menu, with one per line
            menu+=("$( echo "$entry" | awk -v FS="::" '{print $1}' )")
            menu+=("$( echo "$entry" | awk -v FS="::" '{print $7}' )")
            id_vendor="$( /sbin/udevadm info --query=property --name="$part" | grep "ID_VENDOR_ID=" | sed -e 's|^.*VENDOR_ID=||g' )"
            id_vendor="$( lsusb | grep "ID ${id_vendor}:" | sed -e "s|^.*${id_vendor}:||g" | awk '{print $2" "$3}' )"

            if echo "$entry" | awk -v FS="::" '{print $5}' | grep -qsE "(no name|swap)" ; then
                menu+=("$( echo "$entry" | awk -v FS="::" -v id_vendor="$id_vendor" '{print id_vendor}' )")
            else
                menu+=("$( echo "$entry" | awk -v FS="::" -v id_vendor="$id_vendor" '{print id_vendor " - "$5}' )")
            fi
        fi
    done 3<<< "$( partitions-list --show-all --show-disks | awk -v FS="::" '{if ($3 != "swap") print $0}' )"
    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  guitool
#   DESCRIPTION:  small tool for interact with the user graphically
#    PARAMETERS:  $1 = mode, $2 = message, $3 = "%s" equivalent vars for $2
#       RETURNS:  value, if needed
#===============================================================================
guitool(){
    # pre {{{
    local mode message
    #el_debug

    mode="$1"
    message="$2"

    el_check_variables "mode,guitool"

    #el_debug "    $FUNCNAME $@"

    # }}}
    # functions {{{
    # This is not going to work here because gettext is unable to get the messages from a dynamic variable
    #    local _translated_message
    #    _translated_message="$( printf "$( eval_gettext "$message" )" "$@" )"

    case "$mode" in
        info)
            guitool working_stop
            el_check_variables "message"
            $guitool --info --text="$message"

            ;;
        error)
            guitool working_stop
            el_check_variables "message"
            $guitool --error --text="$message"

            ;;
        warning)
            guitool working_stop
            el_check_variables "message"
            $guitool --warning --text="$message"

            ;;
        working_start)
            # already running? keep it running instead of creating a new one
            if [[ -s "$TMP_PROGRESS_WORKING_f" ]] || ((is_guitool_working_running)) ; then
                return
            fi

            echo working > "$TMP_PROGRESS_WORKING_f"
            sync
            is_guitool_working_running=1


            if [[ -n "$message" ]] ; then
                message_doing_magic="$message"
            else
                # random message generator
                message_doing_magic="$( eval_gettext "Elive is doing some magic..." )"
                # random message generator
                case "$( shuf -i 1-5 -n 1 )" in
                    1)
                        message_doing_magic="$( eval_gettext "Elive is doing some magic..." )"
                        ;;
                    2)
                        message_doing_magic="$( eval_gettext "Transferring bytes at the speed of light..." )"
                        ;;
                    3)
                        message_doing_magic="$( eval_gettext "Arranging some atoms in the universe..." )"
                        ;;
                    4)
                        message_doing_magic="$( eval_gettext "Mutating frogs with unicorns..." )"
                        ;;
                    5)
                        message_doing_magic="Dancing 'Staying Elive' by the Bee Gees..."
                        ;;
                esac
            fi

            { ( while test -s "$TMP_PROGRESS_WORKING_f" ; do echo 10 ; cat "$TMP_PROGRESS_WORKING_f" || true ; sleep 1 ; done | $guitool --progress --text="$message_doing_magic" --pulsate --auto-close ) & disown ; } 2>/dev/null

            ;;
        working_stop)
            rm -f "$TMP_PROGRESS_WORKING_f"
            unset is_guitool_working_running

            ;;
        question)
            guitool working_stop
            el_check_variables "message"

            if $guitool --question --text="$message" ; then
                return 0
            else
                return 1
            fi

            ;;
    esac
    # }}}
}

main(){
    # pre {{{
    local url_image_stable url_image_beta menu id_vendor


    el_dependencies_check "dd,lynx,wget,zsync"

    if ! guitool question "$( eval_gettext "This tool will create an USB bootable media that you can use for boot Elive in any computer, all the data inside the USB is going to be deleted. Do you want to continue?" )" ; then
        exit
    fi

    mkdir -p "$cache_dir"
    cd "$cache_dir"

    # }}}

    # select version {{{
    if guitool question "$( eval_gettext "Do you have an already downloaded Elive version? Otherwise we will download the last one." )" ; then
        image_filename="$( $guitool --file-selection --filename="$( xdg-user-dir DOWNLOAD )/" --file-filter="*.img *.IMG *.iso *.ISO" || echo cancel )"

        if [[ -s "$image_filename" ]] && ! [[ "$image_filename" = "cancel" ]] && ! [[ -z "$image_filename" ]] ; then
            is_image_given=1
            image_version="$( echo "$image_filename" | sed -e 's|^.*/||g' -e 's|elive_||g' -e 's|_.*$||g' )"
            if ! echo "$image_version" | grep -qs "^[[:digit:]].*[[:digit:]]$" ; then
                image_version="$( basename "$image_filename" )"
                guitool info "$( eval_gettext "This doesn't looks like to be a normal Elive version, but we will try to use it anyways." )"
            fi
        else
            unset image_filename
            unset is_image_given
        fi
    else

        # ask for img / iso
        if guitool question "$( eval_gettext "Do you want to use the IMG version? The IMG version can have persistence with encryption, but the ISO version can be compatible with rare hardware." )" ; then
            image_extension="img"
        else
            image_extension="iso"
        fi

        guitool working_stop
        guitool working_start

        image_stable_url="$( lynx -dump "${url_elive}/download/stable/" | grep "${url_elive}/downloads/stable/.*\.${image_extension}" | sed -e 's|^.*www\.|www.|g' | sort -V | tail -1 )"
        read -r image_stable_url <<< "$image_stable_url"
        image_stable_version="${image_stable_url%/*}"
        image_stable_version="${image_stable_version##*/}"
        image_stable_filename="${image_stable_url##*/}"

        image_beta_url="$( lynx -dump "${url_elive}/download/beta/" | grep "${url_elive}/downloads/other/.*\.${image_extension}" | sed -e 's|^.*www\.|www.|g' | sort -V | tail -1 )"
        read -r image_beta_url <<< "$image_beta_url"
        image_beta_version="${image_beta_url%/*}"
        image_beta_version="${image_beta_version##*/}"
        image_beta_filename="${image_beta_url##*/}"

        if [[ -n "$image_stable_url" ]] && [[ -n "$image_beta_url" ]] ; then
            # ask version to use
            if guitool question "$( eval_gettext "Do you want to use the last Beta version instead of the Stable?" )" ; then
                image_url="$image_beta_url"
                image_version="$image_beta_version"
                image_filename="$image_beta_filename"
                image_subdir="development"
            else
                image_url="$image_stable_url"
                image_version="$image_stable_version"
                image_filename="$image_stable_filename"
                image_subdir="stable"
            fi

        else
            # only beta available
            if [[ -z "$image_stable_url" ]] ; then
                image_url="$image_beta_url"
                image_version="$image_beta_version"
                image_filename="$image_beta_filename"
                image_subdir="development"
            fi

            # only stable available
            if [[ -z "$image_beta_url" ]] ; then
                image_url="$image_stable_url"
                image_version="$image_stable_version"
                image_filename="$image_stable_filename"
                image_subdir="stable"
            fi
        fi

        # checks
        if [[ -z "$image_url" ]] ; then
            guitool error "$( eval_gettext "No versions of Elive for USB available found from the website." )"
            el_error "no versions found on the website"
            exit 1
        fi

        # get redirector, specially needed for zsync to work
        guitool working_start
        _image_url="$( LC_ALL=C timeout 10 wget --verbose "$image_url" -O /dev/null 2>&1 | grep -i "Location:.*following" | sed -e 's|^Location: ||g' -e 's|\[follow.*$||g' )"
        if [[ "$_image_url" = http* ]] ;  then
            image_url="$_image_url"
            read -r image_url <<< "$image_url"
        fi

    fi

    # - select version }}}
    # download images {{{
    if ! ((is_image_given)) ; then
        mkdir -p "$cache_dir/downloads/${image_subdir}/${image_extension}"
        cd "$cache_dir/downloads/${image_subdir}/${image_extension}"

        image_md5="${image_filename%.*}.md5"
        rm -f "$image_md5"

        # download the md5
        case "$image_extension" in
            img)
                wget $wgetopts --quiet "${image_url%/*}/${image_filename%.img}.md5"
                ;;
            iso)
                wget $wgetopts --quiet "${image_url%/*}/${image_filename%.iso}.md5"
                ;;
        esac

        if [[ -s "$image_filename" ]] ; then
            # download ready to use
            # TODO: check md5 to know that is valid
            guitool working_start
            if md5sum -c "${image_md5}" ; then
                is_checksum_ok=1
            else
                is_redownload_wanted=1
            fi
            guitool working_stop
        else
            image_old="$( ls -1 *.img 2>/dev/null | sort -V | tail -1 )"

            # re-use with zsync
            if [[ -s "$image_old" ]] ; then
                # use zsync
                rm -rf old
                mkdir -p old
                mv -f elive*${image_extension} old/

                # TODO: test if works with the temporal url
                zsync -i "old/${image_old}" "${image_url}.zsync" 1>"$TMP_PROGRESS_WORKING_f" 2>"$TMP_ERROR_LOGS_f" &
                # TODO: catch errors too, and search for an error to show to the user, like "No space left on device"
                pid="$!"
                sleep 2

                local message_downloading
                message_downloading="$( printf "$( eval_gettext "Synchronizing to Elive %s, please be patient..." )" "$image_version" )"

                local message_comparing
                message_comparing="$( printf "$( eval_gettext "Searching particles in the universe to recycle, to save you around the 90 percent of the needed download!" )" "" )"


                while kill -0 "$pid" 2>/dev/null
                do
                    progress="$( cat "$TMP_PROGRESS_WORKING_f" | grep % | tail -1 | tr ' ' '\n' | grep % | sed -e 's|%||g' -e 's|\..*$||g' | tail -1 )"
                    if [[ "$progress" = 100 ]] ; then
                        #if ! shuf -i 30-70 -n 1 2>/dev/null ; then
                        #echo "50"
                        #fi
                        echo "# $message_comparing"
                    else
                        #echo "$progress"
                        echo "# ${message_downloading}: ${progress} %"
                    fi
                    sleep 5
                done | $guitool --progress --pulsate --auto-close --text="$( eval_gettext "$message_downloading" )" || exit 1

                # cleanups
                rm -f rcksum-*

                # TODO: add a function to verify signature
                #guitool working_start
                if md5sum -c "${image_md5}" ; then
                    is_checksum_ok=1
                    rm -rf old/
                else
                    guitool error "$( eval_gettext "MD5 verification doesn't match" )"
                    el_error "md5 verification failed"
                    exit 1
                fi
                guitool working_stop
            fi
        fi

        # we don't have it, nor zsynced, download it
        if ! [[ -s "$image_filename" ]] || ((is_redownload_wanted)) ; then
            # TODO: catch errors, like not enough free space?
            LC_ALL=C wget $wgetopts "$image_url" 1>"$TMP_PROGRESS_WORKING_f" 2>"$TMP_ERROR_LOGS_f" &
            pid="$!"
            sleep 2

            local message_downloading
            message_downloading="$( printf "$( eval_gettext "Downloading Elive %s, please be patient..." )" "$image_version" )"

            while kill -0 "$pid" 2>/dev/null
            do
                progress="$( cat "$TMP_PROGRESS_WORKING_f" | grep % | tail -1 | tr ' ' '\n' | grep % | sed -e 's|%||g' -e 's|\..*$||g' | tail -1 )"
                echo "$progress"
                sleep 5
            done | $guitool --progress --auto-close --text="$( eval_gettext "$message_downloading" )" || exit 1

            # TODO:
            guitool working_start
            if ! md5sum -c "${image_md5}" ; then
                rm -f "$image_filename"
            fi
            guitool working_stop
        fi

        if [[ -s "$image_filename" ]] && ! ((is_checksum_ok)) ; then
            guitool working_start
            if md5sum -c "${image_md5}" ; then
                is_checksum_ok=1
            else
                rm -f "$image_filename"
                guitool error "$( eval_gettext "MD5 verification doesn't match" )"
                el_error "md5 verification failed"
                exit 1
            fi
            guitool working_stop
        fi

        if ! ((is_checksum_ok)) ; then
            guitool error "$( eval_gettext "Integrity not verified correctly." )"
            el_error "integrity has not been verified"
            exit 1
        fi
    fi

        # verify md5
    # - download images }}}
    # select device to record Elive {{{
    generate_menu_selector

    # not inserted ? do it!
    if [[ "${#menu[@]}" -lt 3 ]] ; then
        guitool info "$( eval_gettext "Please insert the USB where to record Elive before to continue." )"

        generate_menu_selector
        if [[ "${#menu[@]}" -lt 3 ]] ; then
            sleep 6
            generate_menu_selector
        fi
    fi

    if [[ "${#menu[@]}" -lt 3 ]] ; then
        guitool error "$( eval_gettext "No USB sticks found." )"
        exit 1
    fi


    local message_select_usb
    message_select_usb="$( printf "$( eval_gettext "Select the USB where to record Elive, all the data and partitions inside will be permanently deleted." )" "" )"

    image_device="$( $guitool --list --height=300 --width=600 --text="$message_select_usb" --column="$( eval_gettext "Device" )" --column="$( eval_gettext "Size" )" --column="$( eval_gettext "Details" )" "${menu[@]}" || echo cancel )"

    if [[ "$image_device" = "cancel" ]] || [[ -z "$image_device" ]] || [[ ! -b "$image_device" ]] ; then
        if guitool question "$( eval_gettext "You have not selected any device to use, do you want to exit?" )" ; then
            exit 1
        else
            generate_menu_selector

            image_device="$( $guitool --list --height=300 --width=600 --text="$message_select_usb" --column="$( eval_gettext "Device" )" --column="$( eval_gettext "Size" )" --column="$( eval_gettext "Details" )" "${menu[@]}" || echo cancel )"

            if [[ "$image_device" = "cancel" ]] || [[ -z "$image_device" ]] || [[ ! -b "$image_device" ]] ; then
                el_error "wrong device selected: $image_device"
                exit 1
            fi
        fi
    fi

    # - select device to record Elive }}}

    # record Elive to device {{{
    if [[ -s "$image_filename" ]] && [[ -b "$image_device" ]] ; then
        local message_recording
        message_recording="$( printf "$( eval_gettext "Recording Elive %s to your %s device" )" "$image_version" "$image_device" )"
        if ! echo "$image_version" | grep -qs "^[[:digit:]].*[[:digit:]]$" ; then
            message_recording="$( printf "$( eval_gettext "Recording %s to your %s device" )" "${image_version}" "$image_device" )"
        fi

        guitool working_start "$message_recording"
        if ! dd if="$image_filename" of="$image_device" bs=8M 1>/dev/null 2>&1 ; then
            guitool error "$( eval_gettext "Error recording USB" )"
            el_error "dd was unable to write"
            exit 1
        fi
        sync

        guitool working_stop
    fi

    guitool info "$( eval_gettext "Congratulations, your USB is ready to be used in any computer! Remember that some newer computers requires to disable the UEFI and Secure Boot modes, you can found more info about this on the Elive website." )"

    # }}}
    # delete cache if low space {{{
    free_space="$( LC_ALL=C df -BM | awk '{if ($6 == "/home") print $4}' | sed -e 's|M$||g' | tail -1 )"
    if [[ -z "$free_space" ]] ; then
        free_space="$( LC_ALL=C df -BM | awk '{if ($6 == "/") print $4}' | sed -e 's|M$||g' | tail -1 )"
    fi

    if echo "$free_space" | grep -qs "[[:digit:]]" ; then
        if [[ "$free_space" -lt 40000 ]] ; then
            cd
            rm -rf "$cache_dir"
        fi
    fi

    # - delete images if low space }}}
}


#
#  MAIN
#
main "$@"


# vim: set foldmethod=marker :


