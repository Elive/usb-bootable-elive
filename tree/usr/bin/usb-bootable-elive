#!/bin/bash
source /usr/lib/elive-tools/functions
el_make_environment
. gettext.sh
TEXTDOMAIN="usb_bootable_elive"
export TEXTDOMAIN

guitool="/usr/bin/zenity --window-icon=/usr/share/icons/gnome/256x256/apps/logo-elive.png"
url_elive="www.elivecd.org"
url_isos="isos.elivecd.org"
TMP_MAIN_d="/tmp/.$(basename $0)-${USER}"
TMP_PROGRESS_WORKING_f="${TMP_MAIN_d}/progress-file-working"

# TODO:
set -x
# FIXME: add verifiers, el_error, etc instead of a set -e, also set -e doens't reports anything to the user to know whats going on
set -e

#===  FUNCTION  ================================================================
#          NAME:  guitool
#   DESCRIPTION:  small tool for interact with the user graphically
#    PARAMETERS:  $1 = mode, $2 = message, $3 = "%s" equivalent vars for $2
#       RETURNS:  value, if needed
#===============================================================================
guitool(){
    # pre {{{
    local mode message
    #el_debug

    mode="$1"
    message="$2"

    el_check_variables "mode,guitool"

    #el_debug "    $FUNCNAME $@"

    # }}}

    # This is not going to work here because gettext is unable to get the messages from a dynamic variable
    #    local _translated_message
    #    _translated_message="$( printf "$( eval_gettext "$message" )" "$@" )"

    case "$mode" in
        info)
            guitool working_stop
            el_check_variables "message"
            $guitool --info --text="$message"

            ;;
        error)
            guitool working_stop
            el_check_variables "message"
            $guitool --error --text="$message"

            ;;
        warning)
            guitool working_stop
            el_check_variables "message"
            $guitool --warning --text="$message"

            ;;
        working_start)
            # already running? keep it running instead of creating a new one
            if [[ -s "$TMP_PROGRESS_WORKING_f" ]] || ((is_guitool_working_running)) ; then
                return
            fi

            echo working > "$TMP_PROGRESS_WORKING_f"
            sync
            is_guitool_working_running=1


            if [[ -n "$message" ]] ; then
                message_doing_magic="$message"
            else
                # random message generator
                message_doing_magic="$( eval_gettext "Elive is doing some magic..." )"
                # random message generator
                case "$( shuf -i 1-5 -n 1 )" in
                    1)
                        message_doing_magic="$( eval_gettext "Elive is doing some magic..." )"
                        ;;
                    2)
                        message_doing_magic="$( eval_gettext "Transferring bytes at the speed of light..." )"
                        ;;
                    3)
                        message_doing_magic="$( eval_gettext "Arranging some atoms in the universe..." )"
                        ;;
                    4)
                        message_doing_magic="$( eval_gettext "Mutating frogs with unicorns..." )"
                        ;;
                    5)
                        message_doing_magic="Dancing 'Staying Elive' by the Bee Gees..."
                        ;;
                esac
            fi

            { ( while test -s "$TMP_PROGRESS_WORKING_f" ; do echo 10 ; cat "$TMP_PROGRESS_CONFIGURING_f" || true ; sleep 1 ; done | $guitool --progress --text="$message_doing_magic" --pulsate --auto-close ) & disown ; } 2>/dev/null

            ;;
        working_stop)
            rm -f "$TMP_PROGRESS_WORKING_f"
            unset is_guitool_working_running

            ;;
        question)
            guitool working_stop
            el_check_variables "message"

            if $guitool --question --text="$message" ; then
                return 0
            else
                return 1
            fi

            ;;
    esac
}

main(){
    # pre {{{
    local url_elive url_image_stable url_image_beta cache_dir menu id_vendor

    cache_dir="$HOME/.cache/$(basename $0)"

    el_dependencies_check "dd,lynx,wget,zsync"

    if ! guitool question "$( eval_gettext "This tool will create an USB bootable media that you can use for boot Elive in any computer, all the data inside the USB is going to be deleted. Do you want to continue?" )" ; then
        exit
    fi

    # TODO: betatest it!
    if guitool question "$( eval_gettext "Do you want to use the IMG version? it will feature persistence, but the ISO version can be compatible in other rare hardware." )" ; then
        image_extension="img"
    else
        image_extension="iso"
    fi

    mkdir -p "$cache_dir"
    cd "$cache_dir"

    # }}}

    # select version {{{
    image_stable_url="$( lynx -dump "${url_elive}/download/stable/" | grep "${url_elive}/downloads/stable/.*\.${image_extension}" | sed -e 's|^.*www\.|www.|g' | sort -V | tail -1 )"
    image_stable_version="${image_stable_url%/*}"
    image_stable_version="${image_stable_version##*/}"
    image_stable_filename="${image_stable_url##*/}"

    image_beta_url="$( lynx -dump "${url_elive}/download/beta/" | grep "${url_elive}/downloads/other/.*\.${image_extension}" | sed -e 's|^.*www\.|www.|g' | sort -V | tail -1 )"
    image_beta_version="${image_beta_url%/*}"
    image_beta_version="${image_beta_version##*/}"
    image_beta_filename="${image_beta_url##*/}"

    if [[ -n "$image_stable_url" ]] && [[ -n "$image_beta_url" ]] ; then
        # ask version to use
        if guitool question "$( eval_gettext "Do you want to use the last Beta version instead of the Stable?" )" ; then
            image_url="$image_beta_url"
            image_version="$image_beta_version"
            image_filename="$image_beta_filename"
            image_subdir="development"
        else
            image_url="$image_stable_url"
            image_version="$image_stable_version"
            image_filename="$image_stable_filename"
            image_subdir="stable"
        fi

    else
        # only beta available
        if [[ -z "$image_stable_url" ]] ; then
            image_url="$image_beta_url"
            image_version="$image_beta_version"
            image_filename="$image_beta_filename"
            image_subdir="development"
        fi

        # only stable available
        if [[ -z "$image_beta_url" ]] ; then
            image_url="$image_stable_url"
            image_version="$image_stable_version"
            image_filename="$image_stable_filename"
            image_subdir="stable"
        fi
    fi

    # checks
    if [[ -z "$image_url" ]] ; then
        guitool error "$( eval_gettext "No versions of Elive for USB available found from the website." )"
        exit
    fi


    # - select version }}}
    # download images {{{
    mkdir -p "$cache_dir/downloads"
    cd "$cache_dir/downloads"

    # download the md5
    case "$image_extension" in
        img)
            wget --quiet -c -nc "${url_isos}/${image_subdir}/${image_filename%.img}.md5"
            ;;
        iso)
            wget --quiet -c -nc "${url_isos}/${image_subdir}/${image_filename%.iso}.md5"
            ;;
    esac
    image_md5="${image_filename%.*}.md5"

    if [[ -s "$image_filename" ]] ; then
        # download ready to use
        true
        # TODO: check md5 to know that is valid
        if ! md5sum -c "${image_md5}" ; then
            # TODO: progress bar
            wget --quiet -nc -c "$image_url"
        fi
        if ! md5sum -c "${image_md5}" ; then
            rm -f "$image_filename"
            wget --quiet -nc -c "$image_url"
        fi
    else
        image_old="$( ls -1 *.img | sort -V | tail -1 )"

        # re-use with zsync
        if [[ -s "$image_old" ]] ; then
            # use zsync
            rm -rf old
            mkdir -p old
            mv * old/

            # FIXME: include a progress dialog
            # TODO: test if works with the temporal url
            zsync -i "old/${image_old}" "${image_url}.zsync"

            # FIXME: add a function to verify md5
            # TODO: add a function to verify signature
            if md5sum -c "${image_md5}" ; then
                rm -rf old/
            else
                guitool error "$( eval_gettext "MD5 verification doesn't match" )"
            fi
        fi
    fi

    if [[ -s "$image_filename" ]] ; then
        if ! md5sum -c "${image_md5}" ; then
            rm -f "$image_filename"
            guitool error "$( eval_gettext "MD5 verification doesn't match" )"
            exit 1
        fi
    fi

        # verify md5
    # - download images }}}
    # select device to record Elive {{{
    #  device :: type :: filesystem :: label :: human_label :: size :: human_size :: uuid
    unset menu id_vendor
    while read -ru 3 entry
    do
        part="$( echo "$entry" | awk -v FS="::" '{print $1}' )"
        [[ ! -b "$part" ]] && continue
        # ignore partitions (end in numbers)
        if echo "$part" | grep -qs "[[:digit:]]$" ; then
            continue
        fi

        if /sbin/udevadm info --query=property --name="$part" | grep -qs "ID_USB_DRIVER=usb-storage" ; then
            # create an array for use in the menu, with one per line
            menu+=("$( echo "$entry" | awk -v FS="::" '{print $1}' )")
            menu+=("$( echo "$entry" | awk -v FS="::" '{print $7}' )")
            id_vendor="$( /sbin/udevadm info --query=property --name="$part" | grep "ID_VENDOR_ID=" | sed -e 's|^.*VENDOR_ID=||g' )"
            id_vendor="$( lsusb | grep "ID ${id_vendor}:" | sed -e "s|^.*${id_vendor}:||g" | awk '{print $2" "$3}' )"

            if echo "$entry" | awk -v FS="::" '{print $5}' | grep -qsE "(no name|swap)" ; then
                menu+=("$( echo "$entry" | awk -v FS="::" -v id_vendor="$id_vendor" '{print id_vendor}' )")
            else
                menu+=("$( echo "$entry" | awk -v FS="::" -v id_vendor="$id_vendor" '{print id_vendor " ("$5")"}' )")
            fi
        fi
    done 3<<< "$( partitions-list --show-all --show-disks | awk -v FS="::" '{if ($3 != "swap") print $0}' )"

    # not inserted ? do it!
    if [[ "${#menu[@]}" -lt 3 ]] ; then
        guitool info "$( eval_gettext "Please insert the USB where to record Elive before to continue." )"

        #  device :: type :: filesystem :: label :: human_label :: size :: human_size :: uuid
        unset menu id_vendor
        while read -ru 3 entry
        do
            part="$( echo "$entry" | awk -v FS="::" '{print $1}' )"
            [[ ! -b "$part" ]] && continue
            # ignore partitions (end in numbers)
            if echo "$part" | grep -qs "[[:digit:]]$" ; then
                continue
            fi

            if /sbin/udevadm info --query=property --name="$part" | grep -qs "ID_USB_DRIVER=usb-storage" ; then
                # create an array for use in the menu, with one per line
                menu+=("$( echo "$entry" | awk -v FS="::" '{print $1}' )")
                menu+=("$( echo "$entry" | awk -v FS="::" '{print $7}' )")
                id_vendor="$( /sbin/udevadm info --query=property --name="$part" | grep "ID_VENDOR_ID=" | sed -e 's|^.*VENDOR_ID=||g' )"
                id_vendor="$( lsusb | grep "ID ${id_vendor}:" | sed -e "s|^.*${id_vendor}:||g" | awk '{print $2" "$3}' )"

                if echo "$entry" | awk -v FS="::" '{print $5}' | grep -qsE "(no name|swap)" ; then
                    menu+=("$( echo "$entry" | awk -v FS="::" -v id_vendor="$id_vendor" '{print id_vendor}' )")
                else
                    menu+=("$( echo "$entry" | awk -v FS="::" -v id_vendor="$id_vendor" '{print id_vendor " ("$5")"}' )")
                fi
            fi
        done 3<<< "$( partitions-list --show-all --show-disks | awk -v FS="::" '{if ($3 != "swap") print $0}' )"
    fi

    if [[ "${#menu[@]}" -lt 3 ]] ; then
        guitool error "$( eval_gettext "No USB devices found. Aborted." )"
        exit
    fi


    local message_select_usb
    message_select_usb="$( printf "$( eval_gettext "Select the USB where to record Elive, all the data and partitions inside will be permanently deleted." )" "" )"

    image_device="$( $guitool --list --height=300 --width=600 --text="$message_select_usb" --column="$( eval_gettext "Device" )" --column="$( eval_gettext "Size" )" --column="$( eval_gettext "Details" )" "${menu[@]}" || echo cancel )"

    if [[ "$image_device" = "cancel" ]] ; then
        if guitool question "$( eval_gettext "You have not selected any device to use, do you want to exit?" )" ; then
            exit
        else
            image_device="$( $guitool --list --height=300 --width=600 --text="$message_select_usb" --column="$( eval_gettext "Device" )" --column="$( eval_gettext "Size" )" --column="$( eval_gettext "Details" )" "${menu[@]}" || echo cancel )"

            if [[ "$image_device" = "cancel" ]] ; then
                guitool error "$( eval_gettext "Aborted recording Elive to an USB." )"
                exit
            fi
        fi
    fi

    # - select device to record Elive }}}

    if [[ -s "$image_filename" ]] ; then
        echo dd if="$image_filename" of="$image_device" bs=8M
    fi
}

#
#  MAIN
#
main "$@"


# vim: set foldmethod=marker :


